{"version":3,"file":"diffDOM.js","sources":["../src/diffDOM/virtual/fromDOM.js","../src/diffDOM/dom/fromVirtual.js","../src/diffDOM/dom/apply.js","../src/diffDOM/dom/undo.js","../src/diffDOM/virtual/helpers.js","../src/diffDOM/virtual/apply.js","../src/diffDOM/virtual/fromString.js","../src/diffDOM/virtual/diff.js","../src/diffDOM/index.js","../src/TraceLogger.js"],"sourcesContent":["export const booleanAttributes = {\n    media: [\"muted\", \"autoplay\", \"loop\", \"controls\", \"defaultMuted\"],\n    html: [\"translate\", \"hidden\", \"draggable\", \"spellcheck\"],\n    ol: [\"reversed\"],\n    img: [\"isMap\"],\n    iframe: [ \"allowFullscreen\", \"allowPaymentRequest\" ],\n    object: [\"typeMustMatch\"],\n    video: [\"playsInline\"],\n    track: [\"default\"],\n    form: [\"noValidate\" ],\n    input: [\"autofocus\",\"checked\",\"disabled\",\"formNoValidate\",\"indeterminate\",\"multiple\",\"readOnly\", \"required\"],\n    button: [\"autofocus\", \"disabled\", \"formNoValidate\"],\n    select: [\"autofocus\", \"disabled\", \"multiple\", \"required\"],\n    optgroup: [\"disabled\"],\n    option: [\"disabled\", \"selected\"],\n    textarea: [\"autofocus\", \"disabled\", \"readOnly\", \"required\"],\n    fieldset: [\"disabled\"],\n    details: [\"open\"],\n    dialog: [\"open\"],\n    script: [\"noModule\", \"async\", \"defer\"],\n    frame: [\"noResize\"]\n};\n\nexport function nodeToObj(aNode, options = {}) {\n    const nodeName = aNode.nodeName.toLowerCase();\n    if (nodeName === '#text' || nodeName === '#comment')\n        return {nodeName, data: aNode.data};\n\n    const objNode = {\n        nodeName: nodeName,\n        attributes: {}\n    };\n\n    if (aNode.attributes && aNode.attributes.length > 0) {\n        const nodeArray = Array.prototype.slice.call(aNode.attributes);\n        nodeArray.filter(a => aNode[a.name] !== false).forEach(attribute => {\n            objNode.attributes[attribute.name] = attribute.value;\n        });\n    }\n    if (aNode.value !== undefined)\n        objNode.value = aNode.value;\n    if (aNode.childNodes && aNode.childNodes.length > 0) {\n        const nodeArray = Array.prototype.slice.call(aNode.childNodes);\n        objNode.childNodes = nodeArray.map(childNode => nodeToObj(childNode, options));\n    }\n    let attrs = booleanAttributes[nodeName];\n    if (attrs) {\n        attrs.filter(a => aNode[a]).forEach(a => objNode.attributes[a] = true);\n    }\n    booleanAttributes[\"html\"].filter(a => aNode[a]).forEach(a => objNode.attributes[a] = true);\n    return objNode;\n}\n","import {booleanAttributes} from \"../virtual/fromDOM.js\";\n\nfunction createNode(insideSvg, options, nodeName) {\n    if (insideSvg)\n        return options.document.createElementNS('http://www.w3.org/2000/svg', nodeName);\n    else if (nodeName === 'svg')\n        return options.document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n    return options.document.createElement(nodeName);\n}\n\nexport function objToNode(objNode, insideSvg, options) {\n    const nodeName = objNode.nodeName.toLowerCase();\n\n    if (nodeName === '#text') {\n        return options.document.createTextNode(objNode.data);\n    } else if (nodeName === '#comment') {\n        return options.document.createComment(objNode.data);\n    }\n    let node = createNode(insideSvg, options, nodeName);\n    if (objNode.attributes) {\n        Object.entries(objNode.attributes).forEach(([key, value]) => node.setAttribute(key, value));\n    }\n    if (objNode.childNodes) {\n        objNode.childNodes.forEach(childNode => node.appendChild(objToNode(childNode, insideSvg || nodeName === \"svg\", options)));\n    }\n    if (objNode.value) {\n        node.value = objNode.value;\n    }\n\n    let attrs = booleanAttributes[nodeName];\n\n    if (attrs) {\n        attrs.filter(a => objNode[a]).forEach(a => node[a] = true);\n    }\n    booleanAttributes[\"html\"].filter(a => objNode[a]).forEach(a => node[a] = true);\n\n    return node;\n}\n","import {objToNode} from \"./fromVirtual\"\n\n// ===== Apply a diff =====\n\nfunction getFromRoute(node, route) {\n    route = route.slice()\n    while (route.length > 0) {\n        if (!node.childNodes) {\n            return false\n        }\n        const c = route.splice(0, 1)[0]\n        node = node.childNodes[c]\n    }\n    return node\n}\n\nexport function applyDiff(\n        tree,\n        diff,\n        options // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\n    ) {\n    let _const = options._const;\n    let node = getFromRoute(tree, diff[_const.route])\n    let newNode\n    let reference\n    let route\n    let nodeArray\n    let c\n\n    // pre-diff hook\n    const info = {\n        diff,\n        node\n    }\n\n    if (options.preDiffApply(info)) {\n        return true\n    }\n\n    switch (diff[_const.action]) {\n        case _const.addAttribute:\n            if (!node || !node.setAttribute) {\n                return false\n            }\n        if (diff[_const.value] === true) {\n            node[diff[_const.name]] = true;\n            node.setAttribute(diff[_const.name], \"\")\n        } else\n            node.setAttribute(diff[_const.name], diff[_const.value])\n            break\n        case _const.modifyAttribute:\n            if (!node || !node.setAttribute) {\n                return false\n            }\n            node.setAttribute(diff[_const.name], diff[_const.newValue])\n            if (node.nodeName === 'INPUT' && diff[_const.name] === 'value') {\n                node.value = diff[_const.newValue]\n            }\n            break\n        case _const.removeAttribute:\n            if (!node || !node.removeAttribute) {\n                return false\n            }\n        if (diff[_const.value] === true)\n            node[diff[_const.name]] = false;\n            node.removeAttribute(diff[_const.name])\n            break\n        case _const.modifyTextElement:\n            if (!node || node.nodeType !== 3) {\n                return false\n            }\n            options.textDiff(node, node.data, diff[_const.oldValue], diff[_const.newValue])\n            break\n        case _const.modifyValue:\n            if (!node || typeof node.value === 'undefined') {\n                return false\n            }\n            node.value = diff[_const.newValue]\n            break\n        case _const.modifyComment:\n            if (!node || typeof node.data === 'undefined') {\n                return false\n            }\n            options.textDiff(node, node.data, diff[_const.oldValue], diff[_const.newValue])\n            break\n        case _const.modifyChecked:\n            if (!node || typeof node.checked === 'undefined') {\n                return false\n            }\n            node.checked = diff[_const.newValue]\n            break\n        case _const.modifySelected:\n            if (!node || typeof node.selected === 'undefined') {\n                return false\n            }\n            node.selected = diff[_const.newValue]\n            break\n        case _const.replaceElement:\n            node.parentNode.replaceChild(\n                objToNode(\n                    diff[_const.newValue],\n                    node.namespaceURI === 'http://www.w3.org/2000/svg',\n                    options\n                ),\n                node\n            )\n            break\n        case _const.relocateGroup:\n            nodeArray = Array(...new Array(diff.groupLength)).map(() => node.removeChild(node.childNodes[diff[_const.from]]))\n            nodeArray.forEach((childNode, index) => {\n                if (index === 0) {\n                    reference = node.childNodes[diff[_const.to]]\n                }\n                node.insertBefore(childNode, reference || null)\n            })\n            break\n        case _const.removeElement:\n            node.parentNode.removeChild(node)\n            break\n        case _const.addElement:\n            route = diff[_const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            node = getFromRoute(tree, route)\n            node.insertBefore(\n                objToNode(\n                    diff[_const.element],\n                    node.namespaceURI === 'http://www.w3.org/2000/svg',\n                    options\n                ),\n                node.childNodes[c] || null\n            )\n            break\n        case _const.removeTextElement:\n            if (!node || node.nodeType !== 3) {\n                return false\n            }\n            node.parentNode.removeChild(node)\n            break\n        case _const.addTextElement:\n            route = diff[_const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            newNode = options.document.createTextNode(diff[_const.value])\n            node = getFromRoute(tree, route)\n            if (!node || !node.childNodes) {\n                return false\n            }\n            node.insertBefore(newNode, node.childNodes[c] || null)\n            break\n        default:\n            console.log('unknown action')\n    }\n\n    // if a new node was created, we might be interested in its\n    // post diff hook\n    info.newNode = newNode\n    options.postDiffApply(info)\n\n    return true\n}\n\nexport function applyDOM(tree, diffs, options) {\n    return diffs.every(diff => applyDiff(tree, diff, options))\n}\n","import {applyDiff} from \"./apply\"\n\n// ===== Undo a diff =====\n\nfunction swap(obj, p1, p2) {\n    const tmp = obj[p1]\n    obj[p1] = obj[p2]\n    obj[p2] = tmp\n}\n\nfunction undoDiff(\n    tree,\n    diff,\n    options // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\n) {\n    let _const = options._const;\n\n    switch (diff[_const.action]) {\n        case _const.addAttribute:\n            diff[_const.action] = _const.removeAttribute\n            applyDiff(tree, diff, options)\n            break\n        case _const.modifyAttribute:\n            swap(diff, _const.oldValue, _const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case _const.removeAttribute:\n            diff[_const.action] = _const.addAttribute\n            applyDiff(tree, diff, options)\n            break\n        case _const.modifyTextElement:\n            swap(diff, _const.oldValue, _const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case _const.modifyValue:\n            swap(diff, _const.oldValue, _const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case _const.modifyComment:\n            swap(diff, _const.oldValue, _const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case _const.modifyChecked:\n            swap(diff, _const.oldValue, _const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case _const.modifySelected:\n            swap(diff, _const.oldValue, _const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case _const.replaceElement:\n            swap(diff, _const.oldValue, _const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case _const.relocateGroup:\n            swap(diff, _const.from, _const.to)\n            applyDiff(tree, diff, options)\n            break\n        case _const.removeElement:\n            diff[_const.action] = _const.addElement\n            applyDiff(tree, diff, options)\n            break\n        case _const.addElement:\n            diff[_const.action] = _const.removeElement\n            applyDiff(tree, diff, options)\n            break\n        case _const.removeTextElement:\n            diff[_const.action] = _const.addTextElement\n            applyDiff(tree, diff, options)\n            break\n        case _const.addTextElement:\n            diff[_const.action] = _const.removeTextElement\n            applyDiff(tree, diff, options)\n            break\n        default:\n            console.log('unknown action')\n    }\n\n}\n\nexport function undoDOM(tree, diffs, options) {\n    if (!diffs.length) {\n        diffs = [diffs]\n    }\n    diffs = diffs.slice()\n    diffs.reverse()\n    diffs.forEach(diff => {\n        undoDiff(tree, diff, options)\n    })\n}\n","export class Diff {\n    constructor(options = {}) {\n        Object.entries(options).forEach(([key, value]) => this[key] = value)\n    }\n\n    toString() {\n        return JSON.stringify(this)\n    }\n\n    setValue(aKey, aValue) {\n        this[aKey] = aValue\n        return this\n    }\n}\n\nfunction elementDescriptors(el) {\n    const output = []\n    output.push(el.nodeName)\n    if (el.nodeName !== '#text' && el.nodeName !== '#comment') {\n        if (el.attributes) {\n            if (el.attributes['class']) {\n                output.push(`${el.nodeName}.${el.attributes['class'].replace(/ /g, '.')}`)\n            }\n            if (el.attributes.id) {\n                output.push(`${el.nodeName}#${el.attributes.id}`)\n            }\n        }\n\n    }\n    return output\n}\n\nfunction findUniqueDescriptors(li) {\n    const uniqueDescriptors = {}\n    const duplicateDescriptors = {}\n\n    li.forEach(node => {\n        elementDescriptors(node).forEach(descriptor => {\n            const inUnique = descriptor in uniqueDescriptors\n            const inDupes = descriptor in duplicateDescriptors\n            if (!inUnique && !inDupes) {\n                uniqueDescriptors[descriptor] = true\n            } else if (inUnique) {\n                delete uniqueDescriptors[descriptor]\n                duplicateDescriptors[descriptor] = true\n            }\n        })\n    })\n\n    return uniqueDescriptors\n}\n\nfunction uniqueInBoth(l1, l2) {\n    const l1Unique = findUniqueDescriptors(l1)\n    const l2Unique = findUniqueDescriptors(l2)\n    const inBoth = {}\n\n    Object.keys(l1Unique).forEach(key => {\n        if (l2Unique[key]) {\n            inBoth[key] = true\n        }\n    })\n\n    return inBoth\n}\n\nexport function removeDone(tree) {\n    delete tree.outerDone\n    delete tree.innerDone\n    delete tree.valueDone\n    if (tree.childNodes) {\n        return tree.childNodes.every(removeDone)\n    } else {\n        return true\n    }\n}\n\nexport function isEqual(e1, e2) {\n    if (!['nodeName', 'value', 'checked', 'selected', 'data'].every(element => {\n            if (e1[element] !== e2[element]) {\n                return false\n            }\n            return true\n        })) {\n        return false\n    }\n\n    if (Boolean(e1.attributes) !== Boolean(e2.attributes)) {\n        return false\n    }\n\n    if (Boolean(e1.childNodes) !== Boolean(e2.childNodes)) {\n        return false\n    }\n    if (e1.attributes) {\n        const e1Attributes = Object.keys(e1.attributes)\n        const e2Attributes = Object.keys(e2.attributes)\n\n        if (e1Attributes.length !== e2Attributes.length) {\n            return false\n        }\n        if (!e1Attributes.every(attribute => {\n                if (e1.attributes[attribute] !== e2.attributes[attribute]) {\n                    return false\n                }\n                return true\n            })) {\n            return false\n        }\n    }\n    if (e1.childNodes) {\n        if (e1.childNodes.length !== e2.childNodes.length) {\n            return false\n        }\n        if (!e1.childNodes.every((childNode, index) => isEqual(childNode, e2.childNodes[index]))) {\n\n            return false\n        }\n\n    }\n\n    return true\n}\n\n\nexport function roughlyEqual(e1, e2, uniqueDescriptors, sameSiblings, preventRecursion) {\n\n    if (!e1 || !e2) {\n        return false\n    }\n\n    if (e1.nodeName !== e2.nodeName) {\n        return false\n    }\n\n    if (e1.nodeName === '#text') {\n        // Note that we initially don't care what the text content of a node is,\n        // the mere fact that it's the same tag and \"has text\" means it's roughly\n        // equal, and then we can find out the true text difference later.\n        return preventRecursion ? true : e1.data === e2.data\n    }\n\n\n    if (e1.nodeName in uniqueDescriptors) {\n        return true\n    }\n\n    if (e1.attributes && e2.attributes) {\n\n        if (e1.attributes.id) {\n            if (e1.attributes.id !== e2.attributes.id) {\n                return false\n            } else {\n                const idDescriptor = `${e1.nodeName}#${e1.attributes.id}`\n                if (idDescriptor in uniqueDescriptors) {\n                    return true\n                }\n            }\n        }\n        if (e1.attributes['class'] && e1.attributes['class'] === e2.attributes['class']) {\n            const classDescriptor = `${e1.nodeName}.${e1.attributes['class'].replace(/ /g, '.')}`\n            if (classDescriptor in uniqueDescriptors) {\n                return true\n            }\n        }\n    }\n\n    if (sameSiblings) {\n        return true\n    }\n\n    const nodeList1 = e1.childNodes ? e1.childNodes.slice().reverse() : []\n    const nodeList2 = e2.childNodes ? e2.childNodes.slice().reverse() : []\n\n    if (nodeList1.length !== nodeList2.length) {\n        return false\n    }\n\n    if (preventRecursion) {\n        return nodeList1.every((element, index) => element.nodeName === nodeList2[index].nodeName)\n    } else {\n        // note: we only allow one level of recursion at any depth. If 'preventRecursion'\n        // was not set, we must explicitly force it to true for child iterations.\n        const childUniqueDescriptors = uniqueInBoth(nodeList1, nodeList2)\n        return nodeList1.every((element, index) => roughlyEqual(element, nodeList2[index], childUniqueDescriptors, true, true))\n    }\n}\n\n\nexport function cloneObj(obj) { //  TODO: Do we really need to clone here? Is it not enough to just return the original object?\n    return JSON.parse(JSON.stringify(obj))\n}\n/**\n * based on https://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring#JavaScript\n */\nfunction findCommonSubsets(c1, c2, marked1, marked2) {\n    let lcsSize = 0\n    let index = []\n    const c1Length = c1.length\n    const c2Length = c2.length\n\n    const // set up the matching table\n        matches = Array(...new Array(c1Length + 1)).map(() => [])\n\n    const uniqueDescriptors = uniqueInBoth(c1, c2)\n\n    let // If all of the elements are the same tag, id and class, then we can\n        // consider them roughly the same even if they have a different number of\n        // children. This will reduce removing and re-adding similar elements.\n        subsetsSame = c1Length === c2Length\n\n    if (subsetsSame) {\n\n        c1.some((element, i) => {\n            const c1Desc = elementDescriptors(element)\n            const c2Desc = elementDescriptors(c2[i])\n            if (c1Desc.length !== c2Desc.length) {\n                subsetsSame = false\n                return true\n            }\n            c1Desc.some((description, i) => {\n                if (description !== c2Desc[i]) {\n                    subsetsSame = false\n                    return true\n                }\n            })\n            if (!subsetsSame) {\n                return true\n            }\n        })\n    }\n\n    // fill the matches with distance values\n    for (let c1Index = 0; c1Index < c1Length; c1Index++) {\n        const c1Element = c1[c1Index]\n        for (let c2Index = 0; c2Index < c2Length; c2Index++) {\n            const c2Element = c2[c2Index]\n            if (!marked1[c1Index] && !marked2[c2Index] && roughlyEqual(c1Element, c2Element, uniqueDescriptors, subsetsSame)) {\n                matches[c1Index + 1][c2Index + 1] = (matches[c1Index][c2Index] ? matches[c1Index][c2Index] + 1 : 1)\n                if (matches[c1Index + 1][c2Index + 1] >= lcsSize) {\n                    lcsSize = matches[c1Index + 1][c2Index + 1]\n                    index = [c1Index + 1, c2Index + 1]\n                }\n            } else {\n                matches[c1Index + 1][c2Index + 1] = 0\n            }\n        }\n    }\n\n    if (lcsSize === 0) {\n        return false\n    }\n\n    return {\n        oldValue: index[0] - lcsSize,\n        newValue: index[1] - lcsSize,\n        length: lcsSize\n    }\n}\n\n/**\n * This should really be a predefined function in Array...\n */\nfunction makeArray(n, v) {\n    return Array(...new Array(n)).map(() => v)\n}\n\n/**\n * Generate arrays that indicate which node belongs to which subset,\n * or whether it's actually an orphan node, existing in only one\n * of the two trees, rather than somewhere in both.\n *\n * So if t1 = <img><canvas><br>, t2 = <canvas><br><img>.\n * The longest subset is \"<canvas><br>\" (length 2), so it will group 0.\n * The second longest is \"<img>\" (length 1), so it will be group 1.\n * gaps1 will therefore be [1,0,0] and gaps2 [0,0,1].\n *\n * If an element is not part of any group, it will stay being 'true', which\n * is the initial value. For example:\n * t1 = <img><p></p><br><canvas>, t2 = <b></b><br><canvas><img>\n *\n * The \"<p></p>\" and \"<b></b>\" do only show up in one of the two and will\n * therefore be marked by \"true\". The remaining parts are parts of the\n * groups 0 and 1:\n * gaps1 = [1, true, 0, 0], gaps2 = [true, 0, 0, 1]\n *\n */\nexport function getGapInformation(t1, t2, stable) {\n    const gaps1 = t1.childNodes ? makeArray(t1.childNodes.length, true) : []\n    const gaps2 = t2.childNodes ? makeArray(t2.childNodes.length, true) : []\n    let group = 0\n\n    // give elements from the same subset the same group number\n    stable.forEach(subset => {\n        const endOld = subset.oldValue + subset.length\n        const endNew = subset.newValue + subset.length\n\n        for (let j = subset.oldValue; j < endOld; j += 1) {\n            gaps1[j] = group\n        }\n        for (let j = subset.newValue; j < endNew; j += 1) {\n            gaps2[j] = group\n        }\n        group += 1\n    })\n\n    return {\n        gaps1,\n        gaps2\n    }\n}\n\n/**\n * Find all matching subsets, based on immediate child differences only.\n */\nexport function markSubTrees(oldTree, newTree) {\n    // note: the child lists are views, and so update as we update old/newTree\n    const oldChildren = oldTree.childNodes ? oldTree.childNodes : []\n\n    const newChildren = newTree.childNodes ? newTree.childNodes : []\n    const marked1 = makeArray(oldChildren.length, false)\n    const marked2 = makeArray(newChildren.length, false)\n    const subsets = []\n    let subset = true\n\n    const returnIndex = function() {\n        return arguments[1]\n    }\n\n    const markBoth = i => {\n        marked1[subset.oldValue + i] = true\n        marked2[subset.newValue + i] = true\n    }\n\n    while (subset) {\n        subset = findCommonSubsets(oldChildren, newChildren, marked1, marked2)\n        if (subset) {\n            subsets.push(subset)\n            const subsetArray = Array(...new Array(subset.length)).map(returnIndex)\n            subsetArray.forEach(item => markBoth(item))\n        }\n    }\n\n    oldTree.subsets = subsets\n    oldTree.subsetsAge = 100\n    return subsets\n}\n\nexport class DiffTracker {\n    constructor() {\n        this.list = []\n    }\n\n    add(diffs) {\n        this.list.push(...diffs)\n    }\n    forEach(fn) {\n        this.list.forEach(li => fn(li))\n    }\n\n}\n","import {cloneObj} from \"./helpers\"\n\n// ===== Apply a virtual diff =====\n\nfunction getFromVirtualRoute(tree, route) {\n    let node = tree\n    let parentNode\n    let nodeIndex\n\n    route = route.slice()\n    while (route.length > 0) {\n        if (!node.childNodes) {\n            return false\n        }\n        nodeIndex = route.splice(0, 1)[0]\n        parentNode = node\n        node = node.childNodes[nodeIndex]\n    }\n    return {\n        node,\n        parentNode,\n        nodeIndex\n    }\n}\n\nfunction applyVirtualDiff(\n        tree,\n        diff,\n        options // {preVirtualDiffApply, postVirtualDiffApply, _const}\n    ) {\n    let _const = options._const;\n    const routeInfo = getFromVirtualRoute(tree, diff[_const.route])\n    let node = routeInfo.node\n    const parentNode = routeInfo.parentNode\n    const nodeIndex = routeInfo.nodeIndex\n    const newSubsets = []\n\n    // pre-diff hook\n    const info = {\n        diff,\n        node\n    }\n\n    if (options.preVirtualDiffApply(info)) {\n        return true\n    }\n\n    let newNode\n    let nodeArray\n    let route\n    let c\n    switch (diff[_const.action]) {\n        case _const.addAttribute:\n            if (!node.attributes) {\n                node.attributes = {}\n            }\n\n        if (diff[_const.value] === true) {\n            node[diff[_const.name]] = true;\n            node.attributes[diff[_const.name]] = true;\n        } else\n            node.attributes[diff[_const.name]] = diff[_const.value];\n\n        if (diff[_const.name] === 'value') {\n                node.value = diff[_const.value]\n            }\n\n            break\n        case _const.modifyAttribute:\n            node.attributes[diff[_const.name]] = diff[_const.newValue]\n            break\n        case _const.removeAttribute:\n\n            delete node.attributes[diff[_const.name]]\n\n            if (Object.keys(node.attributes).length === 0) {\n                delete node.attributes\n            }\n\n            if (diff[_const.name] === 'checked') {\n                node.checked = false\n            } else if (diff[_const.name] === 'selected') {\n                delete node.selected\n            } else if (node.nodeName === 'INPUT' && diff[_const.name] === 'value') {\n                delete node.value\n            }\n\n            break\n        case _const.modifyTextElement:\n            node.data = diff[_const.newValue]\n            break\n        case _const.modifyValue:\n            node.value = diff[_const.newValue]\n            break\n        case _const.modifyComment:\n            node.data = diff[_const.newValue]\n            break\n        case _const.modifyChecked:\n            node.checked = diff[_const.newValue]\n            break\n        case _const.modifySelected:\n            node.selected = diff[_const.newValue]\n            break\n        case _const.replaceElement:\n            newNode = cloneObj(diff[_const.newValue])\n            newNode.outerDone = true\n            newNode.innerDone = true\n            newNode.valueDone = true\n            parentNode.childNodes[nodeIndex] = newNode\n            break\n        case _const.relocateGroup:\n            nodeArray = node.childNodes.splice(diff[_const.from], diff.groupLength).reverse()\n            nodeArray.forEach(movedNode => node.childNodes.splice(diff[_const.to], 0, movedNode))\n            if (node.subsets) {\n                node.subsets.forEach(map => {\n                    if (diff[_const.from] < diff[_const.to] && map.oldValue <= diff[_const.to] && map.oldValue > diff[_const.from]) {\n\n                        map.oldValue -= diff.groupLength\n                        const splitLength = map.oldValue + map.length - diff[_const.to]\n                        if (splitLength > 0) {\n                            // new insertion splits map.\n                            newSubsets.push({\n                                oldValue: diff[_const.to] + diff.groupLength,\n                                newValue: map.newValue + map.length - splitLength,\n                                length: splitLength\n                            })\n                            map.length -= splitLength\n                        }\n                    } else if (diff[_const.from] > diff[_const.to] && map.oldValue > diff[_const.to] && map.oldValue < diff[_const.from]) {\n                        map.oldValue += diff.groupLength\n                        const splitLength = map.oldValue + map.length - diff[_const.to]\n                        if (splitLength > 0) {\n                            // new insertion splits map.\n                            newSubsets.push({\n                                oldValue: diff[_const.to] + diff.groupLength,\n                                newValue: map.newValue + map.length - splitLength,\n                                length: splitLength\n                            })\n                            map.length -= splitLength\n                        }\n                    } else if (map.oldValue === diff[_const.from]) {\n                        map.oldValue = diff[_const.to]\n                    }\n                })\n            }\n\n            break\n        case _const.removeElement:\n            parentNode.childNodes.splice(nodeIndex, 1)\n            if (parentNode.subsets) {\n                parentNode.subsets.forEach(map => {\n                    if (map.oldValue > nodeIndex) {\n                        map.oldValue -= 1\n                    } else if (map.oldValue === nodeIndex) {\n                        map.delete = true\n                    } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\n                            map.length--\n                        } else {\n                            newSubsets.push({\n                                newValue: map.newValue + nodeIndex - map.oldValue,\n                                oldValue: nodeIndex,\n                                length: map.length - nodeIndex + map.oldValue - 1\n                            })\n                            map.length = nodeIndex - map.oldValue\n                        }\n                    }\n                })\n            }\n            node = parentNode\n            break\n        case _const.addElement:\n            route = diff[_const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            node = getFromVirtualRoute(tree, route).node\n            newNode = cloneObj(diff[_const.element])\n            newNode.outerDone = true\n            newNode.innerDone = true\n            newNode.valueDone = true\n\n            if (!node.childNodes) {\n                node.childNodes = []\n            }\n\n            if (c >= node.childNodes.length) {\n                node.childNodes.push(newNode)\n            } else {\n                node.childNodes.splice(c, 0, newNode)\n            }\n            if (node.subsets) {\n                node.subsets.forEach(map => {\n                    if (map.oldValue >= c) {\n                        map.oldValue += 1\n                    } else if (map.oldValue < c && (map.oldValue + map.length) > c) {\n                        const splitLength = map.oldValue + map.length - c\n                        newSubsets.push({\n                            newValue: map.newValue + map.length - splitLength,\n                            oldValue: c + 1,\n                            length: splitLength\n                        })\n                        map.length -= splitLength\n                    }\n                })\n            }\n            break\n        case _const.removeTextElement:\n            parentNode.childNodes.splice(nodeIndex, 1)\n            if (parentNode.nodeName === 'TEXTAREA') {\n                delete parentNode.value\n            }\n            if (parentNode.subsets) {\n                parentNode.subsets.forEach(map => {\n                    if (map.oldValue > nodeIndex) {\n                        map.oldValue -= 1\n                    } else if (map.oldValue === nodeIndex) {\n                        map.delete = true\n                    } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\n                            map.length--\n                        } else {\n                            newSubsets.push({\n                                newValue: map.newValue + nodeIndex - map.oldValue,\n                                oldValue: nodeIndex,\n                                length: map.length - nodeIndex + map.oldValue - 1\n                            })\n                            map.length = nodeIndex - map.oldValue\n                        }\n                    }\n                })\n            }\n            node = parentNode\n            break\n        case _const.addTextElement:\n            route = diff[_const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            newNode = {}\n            newNode.nodeName = '#text'\n            newNode.data = diff[_const.value]\n            node = getFromVirtualRoute(tree, route).node\n            if (!node.childNodes) {\n                node.childNodes = []\n            }\n\n            if (c >= node.childNodes.length) {\n                node.childNodes.push(newNode)\n            } else {\n                node.childNodes.splice(c, 0, newNode)\n            }\n            if (node.nodeName === 'TEXTAREA') {\n                node.value = diff[_const.newValue]\n            }\n            if (node.subsets) {\n                node.subsets.forEach(map => {\n                    if (map.oldValue >= c) {\n                        map.oldValue += 1\n                    }\n                    if (map.oldValue < c && (map.oldValue + map.length) > c) {\n                        const splitLength = map.oldValue + map.length - c\n                        newSubsets.push({\n                            newValue: map.newValue + map.length - splitLength,\n                            oldValue: c + 1,\n                            length: splitLength\n                        })\n                        map.length -= splitLength\n                    }\n                })\n            }\n            break\n        default:\n            console.log('unknown action')\n    }\n\n    if (node.subsets) {\n        node.subsets = node.subsets.filter(map => !map.delete && map.oldValue !== map.newValue)\n        if (newSubsets.length) {\n            node.subsets = node.subsets.concat(newSubsets)\n        }\n    }\n\n    // capture newNode for the callback\n    info.newNode = newNode\n    options.postVirtualDiffApply(info)\n\n    return\n}\n\nexport function applyVirtual(tree, diffs, options) {\n    diffs.forEach(diff => {\n        applyVirtualDiff(tree, diff, options)\n    })\n    return true\n}\n","// from html-parse-stringify (MIT)\n\nconst tagRE = /<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>/g\n// re-used obj for quick lookups of components\nconst empty = Object.create ? Object.create(null) : {}\nconst attrRE = /\\s([^'\"/\\s><]+?)[\\s/>]|([^\\s=]+)=\\s?(\".*?\"|'.*?')/g\n\n\nfunction unescape(string) {\n    return string.replace(/&lt;/g, '<').replace(/&gt;/g, '>')\n.replace(/&amp;/g, '&')\n}\n\n// create optimized lookup object for\n// void elements as listed here:\n// http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\nconst lookup = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuItem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n}\n\n\nfunction parseTag(tag) {\n    const res = {\n        nodeName: '',\n        attributes: {}\n    }\n\n    let tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/)\n    if (tagMatch) {\n        res.nodeName = tagMatch[1].toLowerCase()\n        if (lookup[tagMatch[1]] || tag.charAt(tag.length - 2) === '/') {\n            res.voidElement = true\n        }\n\n        // handle comment tag\n        if (res.nodeName.startsWith('!--')) {\n            const endIndex = tag.indexOf('-->')\n            return {\n                type: 'comment',\n                data: endIndex !== -1 ? tag.slice(4, endIndex) : ''\n            }\n        }\n    }\n\n    let reg = new RegExp(attrRE)\n    let result = null\n    let done = false\n    while (!done) {\n        result = reg.exec(tag);\n\n        if (result === null) {\n            done = true;\n        } else if (result[0].trim()) {\n            if (result[1]) {\n                let attr = result[1].trim();\n                let index = attr.indexOf(\"=\");\n                if (index === -1) {\n                    res.attributes[attr] = true;\n                } else {\n                    let key = attr.slice(0, index);\n                    let value = attr.slice(index + 1);\n                    res.attributes[key] = value;\n                    reg.lastIndex--;\n                }\n            } else if (result[2]) res.attributes[result[2]] = result[3].trim().substring(1, result[3].length - 1)\n        }\n    }\n\n    return res\n}\n\nfunction parse(\n    html,\n    options = {components: empty}\n) {\n    const result = []\n    let current\n    let level = -1\n    const arr = []\n    let inComponent = false\n\n    html.replace(tagRE, (tag, index) => {\n        if (inComponent) {\n            if (tag !== (`</${current.nodeName}>`)) {\n                return\n            } else {\n                inComponent = false\n            }\n        }\n        const isOpen = tag.charAt(1) !== '/'\n        const isComment = tag.startsWith('<!--')\n        const start = index + tag.length\n        const nextChar = html.charAt(start)\n        let parent\n\n        if (isComment) {\n            const comment = parseTag(tag)\n\n            // if we're at root, push new base node\n            if (level < 0) {\n                result.push(comment)\n                return result\n            }\n            parent = arr[level]\n            if (parent) {\n                if (!parent.childNodes) {\n                    parent.childNodes = []\n                }\n                parent.childNodes.push(comment)\n            }\n\n            return result\n        }\n\n        if (isOpen) {\n            current = parseTag(tag)\n            level++\n            if (current.type === 'tag' && options.components[current.nodeName]) {\n                current.type = 'component'\n                inComponent = true\n            }\n\n            if (!current.voidElement && !inComponent && nextChar && nextChar !== '<') {\n                if (!current.childNodes) {\n                    current.childNodes = []\n                }\n                current.childNodes.push({\n                    nodeName: '#text',\n                    data: unescape(html.slice(start, html.indexOf('<', start)))\n                })\n            }\n\n            // if we're at root, push new base node\n            if (level === 0) {\n                result.push(current)\n            }\n\n            parent = arr[level - 1]\n\n            if (parent) {\n                if (!parent.childNodes) {\n                    parent.childNodes = []\n                }\n                parent.childNodes.push(current)\n            }\n\n            arr[level] = current\n        }\n\n        if (!isOpen || current.voidElement) {\n            level--\n            if (!inComponent && nextChar !== '<' && nextChar) {\n                // trailing text node\n                // if we're at the root, push a base text node. otherwise add as\n                // a child to the current node.\n                parent = level === -1 ? result : arr[level].childNodes || []\n\n                // calculate correct end of the data slice in case there's\n                // no tag after the text node.\n                const end = html.indexOf('<', start)\n                const data = unescape(html.slice(start, end === -1 ? undefined : end))\n                parent.push({\n                    nodeName: '#text',\n                    data\n                })\n            }\n        }\n    })\n\n    return result[0]\n}\n\nfunction cleanObj(obj) {\n    delete obj.voidElement\n    if (obj.childNodes) {\n        obj.childNodes.forEach(child => cleanObj(child))\n    }\n    return obj\n}\n\nexport function stringToObj(string) {\n    return cleanObj(parse(string))\n}\n","import {Diff, DiffTracker, cloneObj, getGapInformation, isEqual, markSubTrees, removeDone, roughlyEqual} from \"./helpers\"\nimport {applyVirtual} from \"./apply\"\nimport {nodeToObj} from \"./fromDOM\"\nimport {stringToObj} from \"./fromString\"\n\n// ===== Create a diff =====\n\nexport class DiffFinder {\n    constructor(t1Node, t2Node, options) {\n        this.options = options\n        this.t1 = (t1Node instanceof HTMLElement) ? nodeToObj(t1Node, this.options) : (typeof t1Node === 'string') ? stringToObj(t1Node, this.options) : JSON.parse(JSON.stringify(t1Node))\n        this.t2 = (t2Node instanceof HTMLElement) ? nodeToObj(t2Node, this.options) : (typeof t2Node === 'string') ? stringToObj(t2Node, this.options) : JSON.parse(JSON.stringify(t2Node))\n        this.diffcount = 0\n        this.foundAll = false\n        if (this.debug) {\n            this.t1Orig = nodeToObj(t1Node, this.options)\n            this.t2Orig = nodeToObj(t2Node, this.options)\n        }\n\n        this.tracker = new DiffTracker()\n    }\n\n    init() {\n        return this.findDiffs(this.t1, this.t2)\n    }\n\n    findDiffs(t1, t2) {\n        let diffs\n        do {\n            if (this.options.debug) {\n                this.diffcount += 1\n                if (this.diffcount > this.options.diffcap) {\n                    window.diffError = [this.t1Orig, this.t2Orig]\n                    throw new Error(`surpassed diffcap:${JSON.stringify(this.t1Orig)} -> ${JSON.stringify(this.t2Orig)}`)\n                }\n            }\n            diffs = this.findNextDiff(t1, t2, [])\n\n            if (diffs.length === 0) {\n                // Last check if the elements really are the same now.\n                // If not, remove all info about being done and start over.\n                // Sometimes a node can be marked as done, but the creation of subsequent diffs means that it has to be changed again.\n                if (!isEqual(t1, t2)) {\n                    if (this.foundAll) {\n                        console.error('Could not find remaining diffs!')\n                    } else {\n                        this.foundAll = true\n                        removeDone(t1)\n                        diffs = this.findNextDiff(t1, t2, [])\n                    }\n                }\n            }\n            if (diffs.length > 0) {\n                this.foundAll = false\n                this.tracker.add(diffs)\n                applyVirtual(t1, diffs, this.options)\n            }\n        } while (diffs.length > 0)\n\n        return this.tracker.list\n    }\n\n    findNextDiff(t1, t2, route) {\n        let diffs\n        let fdiffs\n\n        if (this.options.maxDepth && route.length > this.options.maxDepth) {\n            return []\n        }\n        // outer differences?\n        if (!t1.outerDone) {\n            diffs = this.findOuterDiff(t1, t2, route)\n            if (this.options.filterOuterDiff) {\n                fdiffs = this.options.filterOuterDiff(t1, t2, diffs)\n                if (fdiffs) diffs = fdiffs\n            }\n            if (diffs.length > 0) {\n                t1.outerDone = true\n                return diffs\n            } else {\n                t1.outerDone = true\n            }\n        }\n        // inner differences?\n        if (!t1.innerDone) {\n            diffs = this.findInnerDiff(t1, t2, route)\n            if (diffs.length > 0) {\n                return diffs\n            } else {\n                t1.innerDone = true\n            }\n        }\n\n        if (!t1.valueDone) {\n            // value differences?\n            diffs = this.findValueDiff(t1, t2, route)\n\n            if (diffs.length > 0) {\n                t1.valueDone = true\n                return diffs\n            } else {\n                t1.valueDone = true\n            }\n        }\n\n        // no differences\n        return []\n    }\n\n    findOuterDiff(t1, t2, route) {\n        const diffs = []\n        let attr\n        let attr1\n        let attr2\n        let attrLength\n        let pos\n        let i\n        let _c = this.options._const;\n        if (t1.nodeName !== t2.nodeName) {\n            if (!route.length) {\n                throw new Error('Top level nodes have to be of the same kind.')\n            }\n            return [{\n                [_c.action]: _c.replaceElement,\n                [_c.oldValue]: cloneObj(t1),\n                [_c.newValue]: cloneObj(t2),\n                [_c.route]: route,\n            }]\n        }\n        if (route.length && this.options.maxNodeDiffCount < Math.abs((t1.childNodes || []).length - (t2.childNodes || []).length)) {\n            return [{\n                [_c.action]: _c.replaceElement,\n                [_c.oldValue]: cloneObj(t1),\n                [_c.newValue]: cloneObj(t2),\n                [_c.route]: route,\n            }]\n        }\n\n        if (t1.data !== t2.data) {\n            // Comment or text node.\n            if (t1.nodeName === '#text') {\n                return [{\n                    [_c.action]: _c.modifyTextElement,\n                    [_c.route]: route,\n                    [_c.oldValue]: t1.data,\n                    [_c.newValue]: t2.data,\n                }]\n            } else {\n                return [{\n                    [_c.action]: _c.modifyComment,\n                     [_c.route]: route,\n                      [_c.oldValue]: t1.data,\n                       [_c.newValue]: t2.data,\n                }]\n            }\n\n        }\n\n        attr1 = t1.attributes ? Object.keys(t1.attributes).sort() : []\n        attr2 = t2.attributes ? Object.keys(t2.attributes).sort() : []\n\n        let index1 = 0, index2 = 0;\n        for (;;) {\n            if (index1 === attr1.length) {\n                // attr2 are all new\n                for (;index2 < attr2.length; index2++) {\n                    let attr = attr2[index2];\n                    let d = ({[_c.action]:_c.addAttribute,\n                             [_c.route]:route,\n                             [_c.name]:attr,\n                          [_c.value]:t2.attributes[attr]});\n                    diffs.push(d);\n                }\n                break;\n            }\n            if (index2 === attr2.length) {\n                // attr1 are all old\n                for (;index1 < attr1.length; index1++) {\n                    let attr = attr1[index1];\n                    diffs.push({\n                        [_c.action]: _c.removeAttribute,\n                               [_c.route]: route,\n                    [_c.name]: attr,\n                        [_c.value]: t1.attributes[attr]}\n                                  );\n                }\n                break;\n            }\n            if (attr1[index1] === attr2[index2]) {\n                // compare\n                let attr = attr1[index1];\n                        let left = t1.attributes[attr], right = t2.attributes[attr] || true;\n                        if (left === \"\")\n                            left = t1[attr] === false ? false : true;\n                        if (left !== right) {\n                            diffs.push({\n                                [_c.action]: _c.modifyAttribute,\n                                [_c.route]: route,\n                                [_c.name]: attr,\n                                [_c.oldValue]: left,\n                                [_c.newValue]: right}\n                                      )\n                        }\n                index1++;\n                index2++;\n            } else if (attr1[index1] < attr2[index2]) {\n                // removeAttribute\n                let attr = attr1[index1];\n                diffs.push({\n                    [_c.action]: _c.removeAttribute,\n                    [_c.route]: route,\n                    [_c.name]: attr,\n                    [_c.value]: t1.attributes[attr],\n                });\n                index1++\n            } else {\n                // add attribute\n                let attr = attr2[index2];\n                diffs.push({\n                    [_c.action]: _c.addAttribute,\n                    [_c.route]: route,\n                    [_c.name]: attr,\n                    [_c.value]: t2.attributes[attr]\n                }\n                          );\n                index2++\n            }\n        }\n\n        return diffs\n    }\n\n    findInnerDiff(t1, t2, route) {\n        const t1ChildNodes = t1.childNodes ? t1.childNodes.slice() : []\n        const t2ChildNodes = t2.childNodes ? t2.childNodes.slice() : []\n        const last = Math.max(t1ChildNodes.length, t2ChildNodes.length)\n        let childNodesLengthDifference = Math.abs(t1ChildNodes.length - t2ChildNodes.length)\n        let diffs = []\n        let index = 0\n        let _c = this.options._const;\n        if (!this.options.maxChildCount || last < this.options.maxChildCount) {\n            const subtrees = t1.subsets && t1.subsetsAge-- ? t1.subsets : (t1.childNodes && t2.childNodes) ? markSubTrees(t1, t2) : []\n\n            if (subtrees.length > 0) {\n                /* One or more groups have been identified among the childnodes of t1\n                 * and t2.\n                 */\n                diffs = this.attemptGroupRelocation(t1, t2, subtrees, route)\n                if (diffs.length > 0) {\n                    return diffs\n                }\n            }\n        }\n\n\n        /* 0 or 1 groups of similar child nodes have been found\n         * for t1 and t2. 1 If there is 1, it could be a sign that the\n         * contents are the same. When the number of groups is below 2,\n         * t1 and t2 are made to have the same length and each of the\n         * pairs of child nodes are diffed.\n         */\n\n        for (let i = 0; i < last; i += 1) {\n            const e1 = t1ChildNodes[i]\n            const e2 = t2ChildNodes[i]\n\n            if (childNodesLengthDifference) {\n                /* t1 and t2 have different amounts of childNodes. Add\n                 * and remove as necessary to obtain the same length */\n                if (e1 && !e2) {\n                    if (e1.nodeName === '#text') {\n                        diffs.push({\n                                   [_c.action]: _c.removeTextElement,\n                                   [_c.route]: route.concat(index),\n                                   [_c.value]: e1.data,\n                                  })\n                        index -= 1\n                    } else {\n                        diffs.push({\n                                   [_c.action]: _c.removeElement,\n                                   [_c.route]: route.concat(index),\n                                   [_c.element]: cloneObj(e1),\n                                  })\n                        index -= 1\n                    }\n\n                } else if (e2 && !e1) {\n                    if (e2.nodeName === '#text') {\n                        diffs.push({\n                            [_c.action]: _c.addTextElement,\n                            [_c.route]: route.concat(index),\n                            [_c.value]: e2.data,\n                        })\n                    } else {\n                        diffs.push({\n                            [_c.action]: _c.addElement,\n                            [_c.route]: route.concat(index),\n                            [_c.element]: cloneObj(e2),\n                        })\n                    }\n                }\n            }\n            /* We are now guaranteed that childNodes e1 and e2 exist,\n             * and that they can be diffed.\n             */\n            /* Diffs in child nodes should not affect the parent node,\n             * so we let these diffs be submitted together with other\n             * diffs.\n             */\n\n            if (e1 && e2) {\n                if (!this.options.maxChildCount || last < this.options.maxChildCount) {\n                    diffs = diffs.concat(this.findNextDiff(e1, e2, route.concat(index)))\n                } else if (!isEqual(e1, e2)) {\n                    if (t1ChildNodes.length > t2ChildNodes.length) {\n                        diffs = diffs.concat([\n                            {\n                                [_c.action]: _c.removeElement,\n                                [_c.element]: cloneObj(e1),\n                            [_c.route]: route.concat(index)\n                        }\n                        ])\n                        t1ChildNodes.splice(i, 1)\n                        index -= 1\n                        childNodesLengthDifference -= 1\n                    } else if (t1ChildNodes.length < t2ChildNodes.length) {\n                        diffs = diffs.concat([\n                            {\n                                [_c.action]: _c.addElement,\n                                [_c.element]: cloneObj(e2),\n                                [_c.route]: route.concat(index)\n                            }\n                        ])\n                        t1ChildNodes.splice(i, 0, {})\n                        childNodesLengthDifference -= 1\n                    } else {\n                        diffs = diffs.concat([\n                            {\n                                [_c.action]: _c.replaceElement,\n                                [_c.oldValue]: cloneObj(e1),\n                                [_c.newValue]: cloneObj(e2),\n                                [_c.route]: route.concat(index)\n                            }\n                        ])\n                    }\n\n                }\n\n            }\n            index += 1\n\n        }\n        t1.innerDone = true\n        return diffs\n    }\n\n    attemptGroupRelocation(t1, t2, subtrees, route) {\n        /* Either t1.childNodes and t2.childNodes have the same length, or\n         * there are at least two groups of similar elements can be found.\n         * attempts are made at equalizing t1 with t2. First all initial\n         * elements with no group affiliation (gaps=true) are removed (if\n         * only in t1) or added (if only in t2). Then the creation of a group\n         * relocation diff is attempted.\n         */\n        const gapInformation = getGapInformation(t1, t2, subtrees)\n        const gaps1 = gapInformation.gaps1\n        const gaps2 = gapInformation.gaps2\n        let shortest = Math.min(gaps1.length, gaps2.length)\n        let destinationDifferent\n        let toGroup\n        let group\n        let node\n        let similarNode\n        let testI\n        const diffs = []\n        let _c = this.options._const;\n\n\n        for (let index2 = 0, index1 = 0; index2 < shortest; index1 += 1, index2 += 1) {\n            if (gaps1[index2] === true) {\n                node = t1.childNodes[index1]\n                if (node.nodeName === '#text') {\n                    if (t2.childNodes[index2].nodeName === '#text') {\n                        if (node.data !== t2.childNodes[index2].data) {\n                            testI = index1\n                            while (t1.childNodes.length > testI + 1 && t1.childNodes[testI + 1].nodeName === '#text') {\n                                testI += 1\n                                if (t2.childNodes[index2].data === t1.childNodes[testI].data) {\n                                    similarNode = true\n                                    break\n                                }\n                            }\n                            if (!similarNode) {\n                                diffs.push({\n                                    [_c.action]: _c.modifyTextElement,\n                                    [_c.route]: route.concat(index2),\n                                    [_c.oldValue]: node.data,\n                                    [_c.newValue]: t2.childNodes[index2].data,\n                                })\n                                return diffs\n                            }\n                        }\n                    } else {\n                        diffs.push({\n                            [_c.action]: _c.removeTextElement,\n                            [_c.route]: route.concat(index2),\n                            [_c.value]: node.data,\n                        })\n                        gaps1.splice(index2, 1)\n                        shortest = Math.min(gaps1.length, gaps2.length)\n                        index2 -= 1\n                    }\n                } else {\n                    diffs.push({\n                        [_c.action]: _c.removeElement,\n                        [_c.route]: route.concat(index2),\n                        [_c.element]: cloneObj(node),\n                    })\n                    gaps1.splice(index2, 1)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index2 -= 1\n                }\n\n            } else if (gaps2[index2] === true) {\n                node = t2.childNodes[index2]\n                if (node.nodeName === '#text') {\n                    diffs.push({\n                        [_c.action]: _c.addTextElement,\n                        [_c.route]: route.concat(index2),\n                        [_c.value]: node.data,\n                    })\n                    gaps1.splice(index2, 0, true)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                } else {\n                    diffs.push({\n                        [_c.action]: _c.addElement,\n                        [_c.route]: route.concat(index2),\n                        [_c.element]: cloneObj(node),\n                    })\n                    gaps1.splice(index2, 0, true)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                }\n\n            } else if (gaps1[index2] !== gaps2[index2]) {\n                if (diffs.length > 0) {\n                    return diffs\n                }\n                // group relocation\n                group = subtrees[gaps1[index2]]\n                toGroup = Math.min(group.newValue, (t1.childNodes.length - group.length))\n                if (toGroup !== group.oldValue) {\n                    // Check whether destination nodes are different than originating ones.\n                    destinationDifferent = false\n                    for (let j = 0; j < group.length; j += 1) {\n                        if (!roughlyEqual(t1.childNodes[toGroup + j], t1.childNodes[group.oldValue + j], [], false, true)) {\n                            destinationDifferent = true\n                        }\n                    }\n                    if (destinationDifferent) {\n                        return [{\n                            [_c.action]: _c.relocateGroup,\n                            ['groupLength']: group.length,\n                            [_c.from]: group.oldValue,\n                            [_c.to]: toGroup,\n                            [_c.route]: route,\n                        }]\n                    }\n                }\n            }\n        }\n        return diffs\n    }\n\n    findValueDiff(t1, t2, route) {\n        // Differences of value. Only useful if the value/selection/checked value\n        // differs from what is represented in the DOM. For example in the case\n        // of filled out forms, etc.\n        const diffs = []\n        let _c = this.options._const;\n\n        if ((t1.value || t2.value) && t1.value !== t2.value && t1.nodeName !== 'OPTION') {\n            diffs.push({\n                [_c.action]: _c.modifyValue,\n                [_c.oldValue]: t1.value || \"\",\n                [_c.newValue]: t2.value || \"\",\n                [_c.route]: route,\n            })\n        }\n\n        return diffs\n    }\n\n}\n","import {applyDOM, undoDOM} from \"./dom/index\"\nimport {DiffFinder} from \"./virtual/index\"\nexport {nodeToObj, stringToObj} from \"./virtual/index\"\n\nconst DEFAULT_OPTIONS = {\n    debug: false,\n    diffcap: 10, // Limit for how many diffs are accepting when debugging. Inactive when debug is false.\n    maxDepth: false, // False or a numeral. If set to a numeral, limits the level of depth that the the diff mechanism looks for differences. If false, goes through the entire tree.\n    maxChildCount: 50, // False or a numeral. If set to a numeral, only does a simplified form of diffing of contents so that the number of diffs cannot be higher than the number of child nodes.\n    // syntax: textDiff: function (node, currentValue, expectedValue, newValue)\n    textDiff(node, currentValue, expectedValue, newValue) {\n        node.data = newValue\n        return\n    },\n    // empty functions were benchmarked as running faster than both\n    // `f && f()` and `if (f) { f(); }`\n    preVirtualDiffApply() {},\n    postVirtualDiffApply() {},\n    preDiffApply() {},\n    postDiffApply() {},\n    filterOuterDiff: null,\n    compress: false, // Whether to work with compressed diffs\n    _const: false, // object with strings for every change types to be used in diffs.\n    document: window && window.document ? window.document : false\n}\n\n\nexport class DiffDOM {\n    constructor(options = {}) {\n\n        this.options = options\n        // IE11 doesn't have Object.assign and buble doesn't translate object spreaders\n        // by default, so this is the safest way of doing it currently.\n        Object.entries(DEFAULT_OPTIONS).forEach(([key, value]) => {\n            if (!Object.prototype.hasOwnProperty.call(this.options, key)) {\n                this.options[key] = value\n            }\n        })\n\n        if (!this.options._const) {\n            const varNames = [\"addAttribute\", \"modifyAttribute\", \"removeAttribute\",\n                \"modifyTextElement\", \"relocateGroup\", \"removeElement\", \"addElement\",\n                \"removeTextElement\", \"addTextElement\", \"replaceElement\", \"modifyValue\",\n                \"modifyChecked\", \"modifySelected\", \"modifyComment\", \"action\", \"route\",\n                \"oldValue\", \"newValue\", \"element\", \"group\", \"from\", \"to\", \"name\",\n                \"value\", \"data\", \"attributes\", \"nodeName\", \"childNodes\", \"checked\",\n                \"selected\"\n            ]\n            this.options._const = {}\n            if (this.options.compress) {\n                varNames.forEach((varName, index) => this.options._const[varName] = index)\n            } else {\n                varNames.forEach(varName => this.options._const[varName] = varName)\n            }\n        }\n\n        this.DiffFinder = DiffFinder\n\n    }\n\n    apply(tree, diffs) {\n        return applyDOM(tree, diffs, this.options)\n    }\n\n    undo(tree, diffs) {\n        return undoDOM(tree, diffs, this.options)\n    }\n\n    diff(t1Node, t2Node) {\n        const finder = new this.DiffFinder(t1Node, t2Node, this.options)\n        return finder.init()\n    }\n\n}\n","/**\n * Use TraceLogger to figure out function calls inside\n * JS objects by wrapping an object with a TraceLogger\n * instance.\n *\n * Pretty-prints the call trace (using unicode box code)\n * when tracelogger.toString() is called.\n */\n\n/**\n * Wrap an object by calling new TraceLogger(obj)\n *\n * If you're familiar with Python decorators, this\n * does roughly the same thing, adding pre/post\n * call hook logging calls so that you can see\n * what's going on.\n */\nexport class TraceLogger {\n    constructor(obj = {}) {\n        this.pad = \"   \"\n        this.padding = \"\"\n        this.tick = 1\n        this.messages = []\n        const wrapkey = (obj, key) => {\n            // trace this function\n            const oldfn = obj[key]\n            obj[key] = (...args) => {\n                this.fin(key, Array.prototype.slice.call(args))\n                const result = oldfn.apply(obj, args)\n                this.fout(key, result)\n                return result\n            }\n        }\n        // can't use Object.keys for prototype walking\n        for (let key in obj) {\n            if (typeof obj[key] === \"function\") {\n                wrapkey(obj, key)\n            }\n        }\n        this.log(\" TRACELOG START\")\n    }\n    // called when entering a function\n    fin(fn, args) {\n        this.padding += this.pad\n        this.log(`> entering ${fn}`, args)\n    }\n    // called when exiting a function\n    fout(fn, result) {\n        this.log(\"< generated return value\", result)\n        this.padding = this.padding.substring(0, this.padding.length - this.pad.length)\n    }\n    // log message formatting\n    format(s, tick) {\n        let nf = function(t) {\n            t = `${t}`\n            while (t.length < 4) {\n                t = `0${t}`\n            }\n            return t\n        }\n        return `${nf(tick)}> ${this.padding}${s}`\n    }\n    // log a trace message\n    log() {\n        let s = Array.prototype.slice.call(arguments)\n        const stringCollapse = function(v) {\n            if (!v) {\n                return \"<falsey>\"\n            }\n            if (typeof v === \"string\") {\n                return v\n            }\n            if (v instanceof HTMLElement) {\n                return v.outerHTML || \"<empty>\"\n            }\n            if (v instanceof Array) {\n                return `[${v.map(stringCollapse).join(\",\")}]`\n            }\n            return v.toString() || v.valueOf() || \"<unknown>\"\n        }\n        s = s.map(stringCollapse).join(\", \")\n        this.messages.push(this.format(s, this.tick++))\n    }\n    // turn the log into a structured string with\n    // unicode box codes to make it a sensible trace.\n    toString() {\n        let cap = \"   \"\n        let terminator = \"\"\n        while (terminator.length <= this.padding.length + this.pad.length) {\n            terminator += cap\n        }\n        let _ = this.padding\n        this.padding = \"\"\n        terminator = this.format(terminator, this.tick)\n        this.padding = _\n        return `${this.messages.join(\"\\n\")}\\n${terminator}`\n    }\n}\n"],"names":["const","booleanAttributes","media","html","ol","img","iframe","object","video","track","form","input","button","select","optgroup","option","textarea","fieldset","details","dialog","script","frame","nodeToObj","aNode","options","nodeName","toLowerCase","data","objNode","attributes","length","Array","prototype","slice","call","filter","a","name","forEach","attribute","value","undefined","childNodes","nodeArray","map","childNode","let","attrs","objToNode","insideSvg","document","createTextNode","createComment","node","createElementNS","createElement","createNode","Object","entries","setAttribute","key","appendChild","getFromRoute","route","c","splice","applyDiff","tree","diff","newNode","reference","_const","info","preDiffApply","action","addAttribute","modifyAttribute","newValue","removeAttribute","modifyTextElement","nodeType","textDiff","oldValue","modifyValue","modifyComment","modifyChecked","checked","modifySelected","selected","replaceElement","parentNode","replaceChild","namespaceURI","relocateGroup","groupLength","removeChild","from","index","to","insertBefore","removeElement","addElement","element","removeTextElement","addTextElement","console","log","postDiffApply","swap","obj","p1","p2","tmp","undoDOM","diffs","reverse","undoDiff","elementDescriptors","el","output","push","replace","id","findUniqueDescriptors","li","uniqueDescriptors","duplicateDescriptors","descriptor","inUnique","uniqueInBoth","l1","l2","l1Unique","l2Unique","inBoth","keys","removeDone","outerDone","innerDone","valueDone","every","isEqual","e1","e2","Boolean","e1Attributes","e2Attributes","roughlyEqual","sameSiblings","preventRecursion","nodeList1","nodeList2","childUniqueDescriptors","cloneObj","JSON","parse","stringify","findCommonSubsets","c1","c2","marked1","marked2","lcsSize","c1Length","c2Length","matches","subsetsSame","some","i","c1Desc","c2Desc","description","c1Index","c1Element","c2Index","c2Element","makeArray","n","v","DiffTracker","this","list","getFromVirtualRoute","nodeIndex","applyVirtual","routeInfo","newSubsets","preVirtualDiffApply","movedNode","subsets","splitLength","delete","concat","postVirtualDiffApply","applyVirtualDiff","add","fn","tagRE","empty","create","attrRE","unescape","string","lookup","area","base","br","col","embed","hr","keygen","link","menuItem","meta","param","source","wbr","parseTag","tag","res","tagMatch","match","charAt","voidElement","startsWith","endIndex","indexOf","type","reg","RegExp","result","done","exec","trim","attr","lastIndex","substring","stringToObj","cleanObj","child","components","current","level","arr","inComponent","parent","isOpen","isComment","start","nextChar","comment","end","DiffFinder","t1Node","t2Node","t1","HTMLElement","t2","diffcount","foundAll","debug","t1Orig","t2Orig","tracker","init","findDiffs","diffcap","window","diffError","Error","findNextDiff","error","fdiffs","maxDepth","findOuterDiff","filterOuterDiff","findInnerDiff","findValueDiff","attr1","attr2","_c","maxNodeDiffCount","Math","abs","sort","index1","index2","d","left","right","t1ChildNodes","t2ChildNodes","last","max","childNodesLengthDifference","maxChildCount","subtrees","subsetsAge","oldTree","newTree","oldChildren","newChildren","subset","returnIndex","arguments","item","markSubTrees","attemptGroupRelocation","destinationDifferent","toGroup","group","similarNode","testI","gapInformation","stable","gaps1","gaps2","endOld","endNew","j","getGapInformation","shortest","min","DEFAULT_OPTIONS","currentValue","expectedValue","compress","DiffDOM","hasOwnProperty","varNames","varName","apply","applyDOM","undo","TraceLogger","pad","padding","tick","messages","wrapkey","oldfn","fin","args","fout","format","s","t","stringCollapse","outerHTML","join","toString","valueOf","terminator","_"],"mappings":"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"}